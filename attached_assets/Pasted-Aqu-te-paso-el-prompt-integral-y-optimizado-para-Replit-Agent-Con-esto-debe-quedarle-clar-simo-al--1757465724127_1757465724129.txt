Aqu√≠ te paso el prompt integral y optimizado para Replit Agent. Con esto debe quedarle clar√≠simo al agente lo que queremos:
Proyecto Qartha, con backend FastAPI + MongoDB + est√°ticos, frontend React/Vite/Tailwind, y todo lo de galer√≠a, documentos, diagramas, tabla homog√©nea, CMS con CSV e incluye el sem√°foro.


You are a senior full-stack engineer. Build a complete mono-repo named **Qartha** that implements a PUBLIC DIRECTORY of IDFs with multi-cluster/multi-project support.

=================================================================
A) BACKEND ‚Äî FastAPI + MongoDB + Static (multi-cluster)
=================================================================
Stack:
- Python 3.11, FastAPI, Pydantic v2, Motor (MongoDB async), python-multipart, uvicorn
- CORS enabled (allow all) for demo
- Serve static files at /static

ENV variables:
- MONGO_URL_ATLAS
- DB_NAME=qartha
- STATIC_DIR=static
- ADMIN_TOKEN=changeme-demo-token
- DEFAULT_CLUSTER=trk
- ALLOWED_CLUSTERS=trk,lab
- DEFAULT_PROJECT=trinity

Data model (Pydantic v2):
- MediaItem { url: HttpUrl, name?: str, kind: "image" | "document" | "diagram" }
- TableColumn { key: str, label: str, type: "text" | "number" | "date" | "select" | "status", options?: [str] }
- IdfTable { columns: TableColumn[], rows: list[dict[str, Any]] }
- HealthCounts { ok:int, revision:int, falla:int, libre:int, reservado:int }
- IdfHealth { level: "green" | "yellow" | "red" | "gray", counts: HealthCounts }
- IdfIndex { cluster:str, project:str, code:str, title:str, site?:str, room?:str, health?: IdfHealth }  // health optional
- IdfPublic {
    cluster:str, project:str, code:str, title:str, description?:str, site?:str, room?:str,
    gallery: MediaItem[], documents: MediaItem[], diagram?: MediaItem, table?: IdfTable,
    health?: IdfHealth
  }
- IdfUpsert { title:str, description?:str, site?:str, room?:str, table?: IdfTable }
- Device { cluster:str, project:str, idf_code:str, name:str, model?:str, serial?:str, rack?:str, site?:str, notes?:str }

Mongo:
- Collections: idfs, devices
- Indexes:
  - idfs: unique compound index on (cluster, project, code)
  - devices: index on (cluster, project, idf_code)

Routing (multi-tenant by path):
- All endpoints are prefixed with: /api/{cluster}/{project}/...
- Static uploads go to: /static/{cluster}/{project}/{images|docs|diagrams}/...
- Validate that {cluster} ‚àà ALLOWED_CLUSTERS; if not, 404.
- Keep a simple helper to coalesce optional headers later (e.g., X-Cluster) but for now use only the path.

Public endpoints (no auth):
- GET  /api/{cluster}/{project}/idfs
    - Query: ?q=<text>&limit=50&skip=0&include_health=0
    - Returns list[IdfIndex]. If include_health=1, compute and include `health` per IDF.
- GET  /api/{cluster}/{project}/idfs/{code}
    - Returns IdfPublic with computed `health`.

Admin endpoints (Bearer ADMIN_TOKEN):
- POST   /api/{cluster}/{project}/idfs?code={IDF_CODE} ‚Üí create IdfPublic from IdfUpsert (project/code/cluster immutable)
- PUT    /api/{cluster}/{project}/idfs/{code}          ‚Üí update (except cluster/project/code)
- DELETE /api/{cluster}/{project}/idfs/{code}
- POST   /api/{cluster}/{project}/assets/images   (multipart: file, form: code)
- POST   /api/{cluster}/{project}/assets/documents(multipart: file, form: code)
- POST   /api/{cluster}/{project}/assets/diagram  (multipart: file, form: code)
- POST   /api/{cluster}/{project}/devices/upload_csv?code=... (multipart csv)
- POST   /api/{cluster}/{project}/devices          (json array of Device)

CSV expected headers (devices):
- name,model,serial,rack,site,notes  // OPTIONAL status (ignored for now)

Health (semaphore) rules (computed on read from `table.rows`):
- Look for a status column: first column with type="status" or key in ["status","estado"].
- Count by value: "OK","Revisi√≥n","Falla","Libre","Reservado".
- Level:
  - any Falla ‚Üí "red"
  - else any Revisi√≥n ‚Üí "yellow"
  - else if (OK+Libre+Reservado)>0 ‚Üí "green"
  - else ‚Üí "gray"

Project layout (backend):
- app/core/config.py        # env, allowed clusters helper
- app/db/mongo.py           # client, db, ensure_indexes()
- app/models/idf_models.py  # models above
- app/routers/public_idfs.py # GET list/detail with health compute
- app/routers/admin_idfs.py  # CRUD for idf
- app/routers/assets.py     # uploads to STATIC_DIR/cluster/project/*
- app/routers/devices.py    # CSV/manual devices
- app/main.py               # FastAPI app, CORS, static mount, router include, startup ensure_indexes
- requirements.txt
- static/ (ensure exists)

Implementation notes:
- Enforce ALLOWED_CLUSTERS in a dependency; reject unknown cluster with 404.
- Upload helpers: ensure directories exist before saving.
- Return URLs as `/static/...` absolute-relative paths.

Seed data (create on first startup if collection empty):
- Cluster: "trk", Project: "trinity", Code: "IDF-1004"
  - title: "IDF 1004", site: "TrinityRail HQ", room: "Rack A"
  - table.columns:
    [
      {key:"tray",label:"Charola",type:"text"},
      {key:"panel",label:"Patch Panel",type:"text"},
      {key:"port",label:"Puerto",type:"number"},
      {key:"fiber_id",label:"Fibra",type:"text"},
      {key:"to_room",label:"Destino (Cuarto)",type:"text"},
      {key:"to_panel",label:"Destino (Panel)",type:"text"},
      {key:"to_port",label:"Puerto Destino",type:"number"},
      {key:"status",label:"Estado",type:"status","options":["OK","Revisi√≥n","Falla","Libre","Reservado"]}
    ]
  - table.rows: at least 6 rows with mixed statuses (OK, Revisi√≥n, Falla)
  - one sample image (png/jpg), one sample document (pdf), one diagram (pdf)
- Cluster: "lab", Project: "demo", Code: "IDF-0001"
  - minimal example with all-OK rows to show green.

Run command:
- uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload


=================================================================
B) FRONTEND ‚Äî React + Vite + Tailwind (multi-cluster)
=================================================================
Stack:
- Vite + React + TypeScript
- TailwindCSS (+ typography), react-router-dom
- pdfjs-dist for PDF viewer (simple canvas viewer)
- Any lightweight lightbox (react-photo-view) for gallery
- Axios (or fetch wrapper), Heroicons, HeadlessUI (Dialog)
- Build to ../static/ui (so backend serves it)

ENV (.env):
- VITE_API_BASE=http://localhost:8000
- VITE_CLUSTERS=trk,lab
- VITE_PROJECTS_trk=trinity
- VITE_PROJECTS_lab=demo
- VITE_DEFAULT_CLUSTER=trk
- VITE_DEFAULT_PROJECT=trinity
- VITE_ADMIN_TOKEN=changeme-demo-token

Routing (public SPA):
- Base routes use params: /:cluster/:project
  - "/" redirect ‚Üí "/{VITE_DEFAULT_CLUSTER}/{VITE_DEFAULT_PROJECT}"
  - "/:cluster/:project"              ‚Üí PublicList
  - "/:cluster/:project/idf/:code"    ‚Üí PublicDetail
  - "/:cluster/:project/cms"          ‚Üí CmsUpload

UI:
- Navbar: brand "Qartha", selectors Cluster y Proyecto (populate from env lists), links: Directorio, CMS
- PublicList:
  - GET /api/{cluster}/{project}/idfs?include_health=1
  - grid de cards con: title, site, room, code, pill de health (global)
  - search local (q) en cliente
- PublicDetail (tabs):
  - Overview: t√≠tulo, metadatos, pill health (OK/Rev/Falla/Libre/Reservado counts)
  - Galer√≠a: grid responsive + lightbox
  - Documentos: list con enlaces target=_blank
  - Diagrama: si .pdf ‚Üí pdfjs viewer; si image ‚Üí <img>
  - Tabla: render din√°mica desde `table.columns` y `table.rows`
    - StatusBadge: chip coloreado por valor (OK green, Revisi√≥n yellow, Falla red, Libre gray, Reservado blue)
    - Leyenda de colores arriba
- CmsUpload:
  - Inputs: cluster, project, idf code
  - Token prellenado desde VITE_ADMIN_TOKEN (editable)
  - Dispositivos: drop CSV ‚Üí POST /api/{cluster}/{project}/devices/upload_csv?code=...
    - bot√≥n para descargar plantilla CSV (headers: name,model,serial,rack,site,notes)
  - Activos: subir imagen/doc/diagrama a sus endpoints
  - Toasts de √©xito/error

Project layout (frontend/):
- src/main.tsx, src/App.tsx
- src/lib/api.ts (wrap: getIdfs, getIdf, uploadCsv, uploadAsset)
- src/components/{Gallery.tsx, DocList.tsx, PdfOrImage.tsx, DataTable.tsx, StatusBadge.tsx, Toast.tsx}
- src/pages/{PublicList.tsx, PublicDetail.tsx, CmsUpload.tsx}
- tailwind.config.js, postcss.config.js, index.html, vite.config.ts
- Build outputs to ../static/ui

Dev proxy:
- vite.config.ts: proxy "/api" ‚Üí "http://localhost:8000"

StatusBadge classes (example):
- green:  bg-green-100 text-green-700 border-green-300
- yellow: bg-yellow-100 text-yellow-700 border-yellow-300
- red:    bg-red-100 text-red-700 border-red-300
- gray:   bg-gray-100 text-gray-700 border-gray-300
- blue:   bg-blue-100 text-blue-700 border-blue-300

=================================================================
C) README + DX
=================================================================
Create README.md with:
1) What Qartha is (public IDF directory; multi-cluster).
2) ENV setup (backend & frontend).
3) How to run (backend, frontend dev, build).
4) Example CURL:
   - Create IDF:
     curl -X POST "http://localhost:8000/api/trk/trinity/idfs?code=IDF-2001" \
       -H "Authorization: Bearer ${ADMIN_TOKEN}" -H "Content-Type: application/json" \
       -d '{ "title":"IDF 2001", "site":"HQ", "room":"A-2", "table":{ "columns":[...], "rows":[] } }'
   - Upload image:
     curl -X POST "http://localhost:8000/api/trk/trinity/assets/images" \
       -H "Authorization: Bearer ${ADMIN_TOKEN}" -F "code=IDF-2001" -F "file=@photo.jpg"
   - List:
     curl "http://localhost:8000/api/trk/trinity/idfs?include_health=1"
   - Detail:
     curl "http://localhost:8000/api/trk/trinity/idfs/IDF-1004"
5) Access UI:
   - Public list:     http://localhost:8000/static/ui/#/trk/trinity
   - Public detail:   http://localhost:8000/static/ui/#/trk/trinity/idf/IDF-1004
   - CMS (uploads):   http://localhost:8000/static/ui/#/trk/trinity/cms

=================================================================
D) DELIVERABLES
=================================================================
- Mono-repo **Qartha** (backend FastAPI + frontend React) fully working.
- Multi-cluster by path ({cluster}/{project}); enforced by ALLOWED_CLUSTERS.
- Static build served by backend (/static/ui).
- Seed created for:
  - trk/trinity ‚Üí IDF-1004 with mixed statuses (shows yellow/red health)
  - lab/demo    ‚Üí IDF-0001 all OK (shows green health)
- Health (semaphore) computed per row (status chips) and global per IDF.
- Pagination params (limit/skip) supported on list.
- Clean, modern UI with tabs and CMS uploader.

OPTIONAL FEATURE: HOST-BASED CLUSTER MAPPING
--------------------------------------------
Future-proof the backend so clusters can be resolved not only from the path
(/api/{cluster}/{project}/...) but also from the request Host header.

Design:
- If env var HOST_CLUSTER_MAP is set (comma separated pairs like "trk=trk.qartha.app,lab=lab.qartha.app"),
  then add middleware/dependency to resolve cluster automatically:
    - Read request.headers["host"] (strip port).
    - If matches a value in HOST_CLUSTER_MAP, infer cluster key.
    - Inject into request.state.cluster.
- Endpoints should still accept cluster in path for backwards compatibility.
- If both path and host mapping exist and mismatch, reject with 400.

Example:
- HOST_CLUSTER_MAP="trk=trk.qartha.app,lab=lab.qartha.app"
- Request:
    GET https://trk.qartha.app/api/trinity/idfs
  ‚Üí cluster resolved as "trk"
- Request:
    GET https://lab.qartha.app/api/demo/idfs
  ‚Üí cluster resolved as "lab"

Implementation detail:
- app/core/config.py ‚Üí parse HOST_CLUSTER_MAP into dict {cluster:hostname}.
- app/middleware/cluster_resolver.py (optional) ‚Üí dependency that checks host.
- Keep fallback: if no HOST_CLUSTER_MAP, ignore and only use path clusters.

üîå EXTRA ‚Äì QR con URL absoluta (demo ‚Üí producci√≥n)
1) requirements.txt (si no lo agregaste antes)
qrcode[pil]==7.4.2

2) app/core/config.py ‚Äì a√±ade PUBLIC_BASE_URL
from pydantic import BaseModel
import os

class Settings(BaseModel):
    MONGO_URL: str = os.getenv("MONGO_URL_ATLAS", "mongodb://localhost:27017")
    DB_NAME: str = os.getenv("DB_NAME", "qartha")
    STATIC_DIR: str = os.getenv("STATIC_DIR", "static")
    ADMIN_TOKEN: str = os.getenv("ADMIN_TOKEN", "changeme-demo-token")
    DEFAULT_CLUSTER: str = os.getenv("DEFAULT_CLUSTER", "trk")
    ALLOWED_CLUSTERS: list[str] = os.getenv("ALLOWED_CLUSTERS", "trk,lab").split(",")
    # üëá Nuevo: base p√∫blica absoluta (https://qartha.mx). Si no se define, se deduce del request.
    PUBLIC_BASE_URL: str | None = os.getenv("PUBLIC_BASE_URL")

settings = Settings()

3) Nuevo: app/routers/qr.py ‚Äì usa PUBLIC_BASE_URL (con fallback al host actual)
import io
import qrcode
from fastapi import APIRouter, Response, HTTPException, Request
from app.db.mongo import db
from app.core.config import settings

router = APIRouter(prefix="/api", tags=["qr"])

def _absolute_frontend_url(request: Request, cluster: str, project: str, code: str) -> str:
    """
    Construye URL absoluta hacia la vista p√∫blica del IDF.
    Prioriza PUBLIC_BASE_URL (producci√≥n). Si no existe, infiere del request (demo).
    """
    base = settings.PUBLIC_BASE_URL
    if not base:
        # Ej: http://host:port  (sin path)
        base = str(request.base_url).rstrip("/")
    # Front SPA hash-route:
    return f"{base}/static/ui/#/{cluster}/{project}/idf/{code}"

@router.get("/{cluster}/{project}/idfs/{code}/qr.png")
async def get_idf_qr_png(cluster: str, project: str, code: str, request: Request):
    # verifica existencia
    doc = await db.idfs.find_one({"cluster": cluster, "project": project, "code": code})
    if not doc:
        raise HTTPException(status_code=404, detail="IDF no encontrado")

    url = _absolute_frontend_url(request, cluster, project, code)

    qr = qrcode.QRCode(version=1, box_size=10, border=4)
    qr.add_data(url)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white")

    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)
    return Response(content=buf.read(), media_type="image/png")

Opcional: si quieres SVG adem√°s de PNG, puedo agregarte /qr.svg con qrcode.image.svg. D√≠melo y te dejo el bloque listo.
4) app/main.py ‚Äì incluye el router
from app.routers.qr import router as qr_router
app.include_router(qr_router)

5) Variables de entorno (ahora y futuro)
Demo/local (sin dominio): no pongas PUBLIC_BASE_URL. El backend usar√° el host actual (ej. https://<tu-repl>.repl.co).


Producci√≥n: define PUBLIC_BASE_URL, por ejemplo:


PUBLIC_BASE_URL=https://qartha.mx


(Si usas subdominios por cluster m√°s adelante, esto sigue funcionando: la ruta incluye /{cluster}/{project}/idf/{code} en el hash).


6) Ejemplos de uso
PNG QR directo (ideal para imprimir etiquetas):

 GET https://<tu-repl>.repl.co/api/trk/trinity/idfs/IDF-1004/qr.png
 Abre un PNG que apunta a:

 {PUBLIC_BASE_URL or request-host}/static/ui/#/trk/trinity/idf/IDF-1004


Frontend del IDF (lo que ver√°n al escanear el QR):

 https://qartha.mx/static/ui/#/trk/trinity/idf/IDF-1004   (en prod)
https://<tu-repl>.repl.co/static/ui/#/trk/trinity/idf/IDF-1004   (en demo)



üîí (Opcional pro) Validaci√≥n de cluster por Host
Si adem√°s usas el extra de host mapping (subdominios ‚Üí cluster) que ya te pas√©, el QR seguir√° funcionando id√©ntico:
El hash conserva /{cluster}/{project} y el frontend lo usa tal cual.


Si activas HOST_CLUSTER_MAP, puedes incluso generar QR sin cluster en la URL (porque el host ya lo implica). Si quieres esa variante, te dejo otra ruta que emite QR bas√°ndose solo en project y code, tomando el cluster del host. Me dices y lo agrego.
BRANDING & LOOK & FEEL
----------------------
Project name: **Qartha Smart Inventory Network**

Color palette:
- Primary: Blue tones (e.g., #1E3A8A navy, #2563EB vivid blue, #60A5FA light blue)
- Accent: Cyan (#06B6D4) for highlights
- Neutral: White (#FFFFFF), Gray-100 (#F3F4F6), Gray-700 (#374151)

Design language:
- Clean, modern, professional
- Dashboard-inspired cards, rounded corners, subtle shadows
- TailwindCSS classes: rounded-2xl, shadow-md, hover:shadow-lg
- Typography: sans-serif (Tailwind defaults), with font-weight semibold for titles
- Icons: Heroicons (outline + solid for action buttons)
- Consistency: All pills (status/semaphore) use filled backgrounds in brand colors

UI components to respect brand:
- Navbar:
  - Left: "Qartha Smart Inventory Network" logo text in bold, blue gradient
  - Right: links (Directorio, CMS) styled as buttons with hover underlines
- Cards (Public List):
  - Blue border-top accent
  - Health pill aligned top-right (green/yellow/red/gray/blue)
  - Title in bold dark-blue (#1E3A8A)
- Tabs (Public Detail):
  - Tailwind tabs styled with underline indicator in primary blue
  - Active tab ‚Üí text-blue-600 font-semibold
- Buttons:
  - Primary: bg-blue-600 text-white hover:bg-blue-700 rounded-lg px-4 py-2
  - Secondary: bg-gray-100 text-gray-800 hover:bg-gray-200
- Table:
  - Zebra striping (odd:bg-gray-50 even:bg-white)
  - Status chips: soft background, colored dot + label (green, yellow, red, blue, gray)
- Toasts:
  - Success: green background with check icon
  - Error: red background with exclamation icon
  - Info: blue background with info icon

QR presentation:
- Endpoint `/qr.png` returns black/white by default (production safe)
- OPTIONAL: For print labels, allow `?color=blue` to generate QR with blue foreground and white background
  - Example: `/api/trk/trinity/idfs/IDF-1004/qr.png?color=blue`

Overall tone:
- Must feel like a **network operations / inventory professional tool**
- Blue = trust, reliability, network intelligence
- Responsive: works on desktop + mobile scanning
- All pages carry a consistent header with brand name "Qartha Smart Inventory Network"

